<!DOCTYPE html>
<html>

<head>
	<!-- Meta -->
	<meta charset="UTF-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	<meta name="generator" content="Jekyll">

	<title>Haskell Skyline</title>
  <meta name="description" content="My thoughts, obeservations, and experiments">

	<!-- CSS & fonts -->
	<link rel="stylesheet" href="/css/main.css">

	<!-- RSS -->
	<link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" />

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/png" href="img/favicon.png">

</head>


<body>
	<div id="wrap">
	  	
	  	<!-- Navigation -->
	  	<nav id="nav">
	<div id="nav-list">
		<a href="/">Home</a>

		<!-- Nav pages -->
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
    
    <!-- Nav links -->
	  <!-- <a href="https://github.com/thereviewindex/monochrome/archive/master.zip">Download</a>
<a href="https://github.com/thereviewindex/monochrome">Project on Github</a>
 -->

	</div>
  
  <!-- Nav footer -->
	
	  <footer>
	
	<span>version 1.0.0</span>

</footer>
	

</nav>

    
    <!-- Icon menu -->
	  <a id="nav-menu">
	  	<div id="menu"></div>
	  </a>

      <!-- Header -->
      
        <header id="header" class="parent justify-spaceBetween">
  <div class="inner w100 relative">
    <span class="f-left">  
      <a href="/">
        <h1>
          <span>the</span>lost<span>packet</span>
        </h1>
      </a>
    </span>
    <span id="nav-links" class="absolute right bottom">
      <!-- Nav pages -->
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
      
      <!-- Nav links -->
	    <!-- <a href="https://github.com/thereviewindex/monochrome/archive/master.zip">Download</a>
<a href="https://github.com/thereviewindex/monochrome">Project on Github</a>
 -->

    </span>
  </div>
</header>




      

    <!-- Main content -->
	  <div id="container">
		  
		<main>

			<article id="post-page">
	<h2>Haskell Skyline</h2>		
	<time datetime="2015-12-12T00:00:00-05:00" class="by-line">12 Dec 2015</time>
	<div class="content">

		<p>Recently I started learning Haskell by studying the <a href="https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0">Intro to FP Programming</a> course on Edx. Since then, I try to model different problems using
Haskell.</p>

<p>One of these problems is the Skyline problem, which goes like this:</p>

<blockquote>
  <p>You are given a set of rectangular buildings in a city, and you should return
the skyline view of the city. Input is a sequence of tuples <script type="math/tex">(x_{left}, height,
x_{right})</script>, each describing a building. The output is a sequence of pairs
<script type="math/tex">(x, height)</script> meaning that the height of skyline changed to <script type="math/tex">height</script> at
the given x coordinate.</p>
</blockquote>

<!-- more -->

<p>For example, for the input:</p>

<script type="math/tex; mode=display">[(1,11,5), (2,6,7), (3,13,9), (12,7,16), (14,3,25), (19,18,22),\\
   (23,13,29), (24,4,28)]</script>

<p>The output should be:</p>

<script type="math/tex; mode=display">[(1,11),(3,13),(9,0),(12,7),(16,3),(19,18),(22,3),(23,13),(29,0)]</script>

<p>Below diagrams show the input buildings and the expected skyline side by side:</p>

<p><img src="/img/skyline.svg" alt="Skyline" /></p>

<h2 id="solving-the-problem">Solving the problem</h2>

<p>You can find an extended analysis of this problem at <a href="https://briangordon.github.io/2014/08/the-skyline-problem.html">Brian Gordon’s blog</a>
, which explains several solutions of <script type="math/tex">O(n^2)</script> and <script type="math/tex">O(n \log n)</script> complexity
to this problem.</p>

<p><del>Since sorting of integers can easily be reduce to this problem in linear time,
this problem isn’t solvable faster than <script type="math/tex">O(n \log n)</script> time.</del> (See comments)</p>

<p>In this post I’m not concerned with the time complexity at all, but mostly with
the simplicity of the solution.</p>

<p>It’s also okay if a solution if contains a false height change, i.e. if we have
two consecutive items in the output that contain the same height. After all, we
are only concerned with how the skyline will look, and having a false change
doesn’t change the shape of skyline.</p>

<h3 id="solution-1-calculate-height-of-skyline-at-all-endpoints">Solution 1. Calculate height of skyline at all endpoints</h3>

<p>We’re only interested at changes to the height of skyline, and height can only
change where a building starts or ends. The height at a point can be calculated
by finding the max height of buildings overlapping that point.</p>

<p>This leads us to the following solution:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">skyline</span> <span class="n">bs</span> <span class="o">=</span> <span class="n">sort</span> <span class="p">(</span><span class="n">foldl</span> <span class="n">add_endpoints</span> <span class="kt">[]</span> <span class="n">bs</span><span class="p">)</span>
             <span class="kr">where</span>
                <span class="n">add_endpoints</span> <span class="n">xs</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="o">=</span>
                  <span class="n">xs</span> <span class="o">++</span> <span class="p">[(</span><span class="n">x1</span><span class="p">,</span> <span class="n">height</span> <span class="n">x1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">height</span> <span class="n">x2</span><span class="p">)]</span>
                <span class="n">height</span> <span class="n">x</span> <span class="o">=</span>
                  <span class="n">maximum</span> <span class="p">(</span><span class="mi">0</span> <span class="o">:</span> <span class="p">[</span><span class="n">h</span><span class="o">|</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">bs</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">x1</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">])</span></code></pre></figure>

<p>This solution has time complexity of <script type="math/tex">O(n^2)</script> and produces some false changes,
but it is very simple and easy to understand.</p>

<p>(We can easily remove the false changes by passing the result through another
function, but this is good enough for our purpose and our goal is to keep things
simple).</p>

<h3 id="solution-2-iteratively-add-buildings">Solution 2. Iteratively add buildings</h3>

<p>One might think we can iteratively add buildings and update the shape of skyline.
Since a building can be taller or shorter than the previously added buildings, we
may need to handle several cases to make this work correctly.</p>

<p>But if we sort the buildings by height before adding them, we can make the update
much simpler. If we know the height of skyline is shorter than current building,
then all we need to do is to remove the previous points between the boundries of
the current building (since they won’t be visible anymore), and then add the two
points of building.</p>

<p>This leads us to the following solution:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">skyline</span> <span class="n">bs</span> <span class="o">=</span> <span class="n">sort</span> <span class="p">(</span><span class="n">foldl</span> <span class="n">add_building</span> <span class="kt">[]</span> <span class="p">(</span><span class="n">sortWith</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="kr">_</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">)</span> <span class="n">bs</span><span class="p">))</span>
             <span class="kr">where</span>
                <span class="n">height</span> <span class="n">xs</span> <span class="n">y</span> <span class="o">=</span>
                  <span class="p">(</span><span class="n">snd</span> <span class="o">.</span> <span class="n">maximum</span><span class="p">)</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span><span class="o">|</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">])</span>
                <span class="n">add_building</span> <span class="n">xs</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="o">=</span>
                  <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span><span class="o">|</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">x1</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">x2</span><span class="p">]</span> <span class="o">++</span>
                  <span class="p">[(</span><span class="n">x1</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">height</span> <span class="n">xs</span> <span class="n">x2</span><span class="p">)]</span></code></pre></figure>

<p><strong>Update</strong>. Initial version of this code, which wrongly added <code class="highlighter-rouge">(x2, 0)</code>
in <code class="highlighter-rouge">add_building</code> was incorrect, for the reason described by Chris_Newton
in <a href="https://news.ycombinator.com/item?id=10723920">here</a>.</p>

<p>I think this also looks very simple, although not as simple as the previous
solution, with the advantage that it won’t generate false height changes as
much as previous solution.</p>

<p>The time complexity of this solution is <script type="math/tex">O(n^2)</script>, but if we had used some sort
of sorted search tree with <script type="math/tex">O(\log n)</script> operations instead of using lists,
this could easily be improved to <script type="math/tex">O(n \log n)</script>. After all what we do here is one
simple iteration with <code class="highlighter-rouge">foldl</code>, and then adding each point exactly once, and
removing each end point at most once.</p>

<p>Note that <code class="highlighter-rouge">height xs y</code> can also be implemented in <script type="math/tex">O(\log n)</script> if xs is
some kind of sorted search tree.</p>

<h3 id="solution-3-divide-and-conquer">Solution 3. Divide and Conquer</h3>

<p>Since this is functional programming and solutions usually tend to be solved using
recursion, we could use a solution similar to merge sort. That is, solve the shape
of skyline for each half of the buildings, and then merge the shapes.</p>

<p>The solution will look like:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">skyline</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">skyline</span> <span class="p">[(</span><span class="n">x1</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">x2</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x1</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="n">skyline</span> <span class="n">bs</span> <span class="o">=</span> <span class="p">(</span><span class="n">skyline</span> <span class="p">(</span><span class="n">take</span> <span class="n">n</span> <span class="n">bs</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="p">`</span><span class="n">merge</span><span class="p">`</span> <span class="p">(</span><span class="n">skyline</span> <span class="p">(</span><span class="n">drop</span> <span class="n">n</span> <span class="n">bs</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
              <span class="kr">where</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span> <span class="n">bs</span><span class="p">)</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">2</span>

<span class="n">merge</span> <span class="p">(</span><span class="kt">[]</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">ys</span>
<span class="n">merge</span> <span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="p">(</span><span class="kt">[]</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">xs</span>
<span class="n">merge</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">xh</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">,</span> <span class="n">xh_p</span><span class="p">)</span> <span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">yh</span><span class="p">)</span><span class="o">:</span><span class="n">ys</span><span class="p">,</span> <span class="n">yh_p</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span>  <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">max</span> <span class="n">xh</span>   <span class="n">yh_p</span><span class="p">)</span> <span class="o">:</span> <span class="n">merge</span> <span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">xh</span><span class="p">)</span>           <span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">yh</span><span class="p">)</span><span class="o">:</span><span class="n">ys</span><span class="p">,</span> <span class="n">yh_p</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">max</span> <span class="n">xh</span>   <span class="n">yh</span><span class="p">)</span>   <span class="o">:</span> <span class="n">merge</span> <span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">xh</span><span class="p">)</span>           <span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">yh</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>  <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">max</span> <span class="n">xh_p</span> <span class="n">yh</span><span class="p">)</span>   <span class="o">:</span> <span class="n">merge</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">xh</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">,</span> <span class="n">xh_p</span><span class="p">)</span> <span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">yh</span><span class="p">)</span></code></pre></figure>

<p>The <code class="highlighter-rouge">merge</code> function doesn’t seem very simple, so I wouldn’t use this solution
if I could use a simpler solution.</p>

<p>Similar to merge sort, the time complexity of this solution is <script type="math/tex">O(n \log n)</script>.</p>

<h3 id="conclusion">Conclusion</h3>

<p>There are other solutions to this problem too, but I think these three solutions
are good representative of the solution space. I love problems which can be solved
in several totally different ways, and I found it beautiful that some of the
solutions are strikingly simple and easy to understand.</p>

<h3 id="related-links">Related Links</h3>
<ul>
  <li><a href="https://news.ycombinator.com/item?id=10722094">Hacker News discussion</a></li>
  <li><a href="https://www.reddit.com/r/haskell/comments/3wiqdy/haskell_skyline/">Reddit discussion</a></li>
</ul>


		
	</div>
	
	  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = '';
	(function() {
	    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	    dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
	    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

	
</article>



	  </main>
		
		  <!-- Pagination links -->
      

	  </div>
	    
	    <!-- Footer -->
	    <footer><span>@2017 - Monochrome</span></footer>


	    <!-- Script -->
      <script src="/js/main.js"></script>	


	</div>
</body>
</html>
